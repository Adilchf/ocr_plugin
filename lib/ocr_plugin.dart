library ocr_plugin;

import 'dart:io';
import 'dart:math' as math;
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'dart:typed_data';
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'package:image/image.dart' as img;
import 'ocr_plugin_platform_interface.dart';

/// Data holder for OCR extraction
class OcrResult {
  final String? nin;
  final String? nif;
  final String? cardNumber;
  final String? cardNumberPassport;
  final String? familyName;
  final String? societyName;
  final String? familyNamePassport;
  final String? givenName;
  final String? birthdate;
  final String? expiryDate;
  final String? rhfactor;

  // ðŸ‘‡ New fields
  final bool? faceOk; // true if face passed checks
  final String? faceError; // reason if failed (e.g. "Closed eyes")
  final String? facePath; // saved cropped face path (if any)

  OcrResult({
    this.nin,
    this.nif,
    this.cardNumber,
    this.cardNumberPassport,
    this.familyName,
    this.societyName,
    this.familyNamePassport,
    this.givenName,
    this.birthdate,
    this.expiryDate,
    this.rhfactor,
    this.faceOk,
    this.faceError,
    this.facePath,
  });

  Map<String, dynamic> toJson() => {
    'nin': nin,
    'nif': nif,
    'cardNumber': cardNumber,
    'cardNumberPassport': cardNumberPassport,
    'familyName': familyName,
    'societyName': societyName,
    'familyNamePassport': familyNamePassport,
    'givenName': givenName,
    'birthdate': birthdate,
    'expiryDate': expiryDate,
    'RhFactor': rhfactor,
    'faceOk': faceOk,
    'faceError': faceError,
    'facePath': facePath,
  };

  factory OcrResult.fromJson(Map<String, dynamic> json) => OcrResult(
    nin: json['nin'],
    nif: json['nif'],
    cardNumber: json['cardNumber'],
    cardNumberPassport: json['cardNumberPassport'],
    familyName: json['familyName'],
    societyName: json['societyName'],
    familyNamePassport: json['familyNamePassport'],
    givenName: json['givenName'],
    birthdate: json['birthdate'],
    expiryDate: json['expiryDate'],
    rhfactor: json['RhFactor'],
    faceOk: json['faceOk'],
    faceError: json['faceError'],
    facePath: json['facePath'],
  );
}

/// Main plugin API exposed to Flutter apps
class OcrPlugin {
  /// Test method generated by the plugin template
  static Future<String?> getPlatformVersion() {
    return OcrPluginPlatform.instance.getPlatformVersion();
  }

  /// Run OCR on an image file
  static const double _eyesClosedThresh = 0.3; // < 0.3 considered closed
  static const double _maxYaw = 10.0; // degrees (Y)
  static const double _maxRoll = 10.0; // degrees (Z)

  // Detect a single face and run simple quality checks.
  static Future<({Face? face, String? error, File? usedFile})> _detectFace(
    File imageFile,
  ) async {
    Future<List<Face>> _runDetection(File f, {double minFace = 0.05}) async {
      final inputImage = InputImage.fromFilePath(
        f.path,
      ); // ML Kit handles EXIF orientation
      final detector = FaceDetector(
        options: FaceDetectorOptions(
          performanceMode: FaceDetectorMode.accurate,
          enableClassification: true,
          enableContours: false,
          minFaceSize: minFace, // smaller -> can detect tiny faces
        ),
      );
      try {
        return await detector.processImage(inputImage);
      } finally {
        await detector.close();
      }
    }

    // Pass A: original file, multiple minFace
    for (final mf in [0.05, 0.035, 0.025]) {
      final faces = await _runDetection(imageFile, minFace: mf);
      if (faces.isNotEmpty) {
        return (face: faces.first, error: null, usedFile: imageFile);
      }
    }

    // Pass B: upscale once and retry (helps when the card shot is small)
    final upscaled = await _upscaleCopy(imageFile, maxSide: 2200);
    final fileB = upscaled ?? imageFile;
    for (final mf in [0.035, 0.025, 0.015]) {
      final faces = await _runDetection(fileB, minFace: mf);
      if (faces.isNotEmpty) {
        return (face: faces.first, error: null, usedFile: fileB);
      }
    }

    // Pass C: scan ROIs (left/right/center thirds), using the larger image if available
    final roiFiles = await _roiCrops(fileB);
    for (final roi in roiFiles) {
      for (final mf in [0.03, 0.02, 0.01]) {
        final faces = await _runDetection(roi, minFace: mf);
        if (faces.isNotEmpty) {
          // NOTE: return the ROI file so _cropFace crops in the same coordinate space
          return (face: faces.first, error: null, usedFile: roi);
        }
      }
    }

    return (face: null, error: 'No face detected', usedFile: null);
  }

  // One-time upscale to help tiny portraits (keeps aspect ratio)
  static Future<File?> _upscaleCopy(
    File imageFile, {
    int maxSide = 2200,
  }) async {
    final bytes = await imageFile.readAsBytes();
    final decoded0 = img.decodeImage(bytes);
    if (decoded0 == null) return null;

    final upright = img.bakeOrientation(
      decoded0,
    ); // ensure upright before resampling
    final w = upright.width, h = upright.height;
    final biggest = math.max(w, h);
    if (biggest >= maxSide) return null; // already large enough

    final scale = maxSide / biggest;
    final resized = img.copyResize(
      upright,
      width: (w * scale).round(),
      height: (h * scale).round(),
    );

    final outPath = _withSuffix(imageFile.path, '_up', fallbackExt: '.jpg');
    await File(outPath).writeAsBytes(img.encodeJpg(resized, quality: 95));
    return File(outPath);
  }

  // Heuristic ROIs: left / right / center thirds (full height) â€“ common ID portrait areas
  static Future<List<File>> _roiCrops(File imageFile) async {
    final bytes = await imageFile.readAsBytes();
    final decoded0 = img.decodeImage(bytes);
    if (decoded0 == null) return [];

    final upright = img.bakeOrientation(decoded0);
    final W = upright.width, H = upright.height;

    File saveCrop(int x, int y, int w, int h, String suffix) {
      x = x.clamp(0, W - 1);
      y = y.clamp(0, H - 1);
      w = w.clamp(1, W - x);
      h = h.clamp(1, H - y);
      final crop = img.copyCrop(upright, x: x, y: y, width: w, height: h);
      // to keep detector quality, keep a reasonable size (e.g., short side ~800)
      final targetShort = 900;
      final short = math.min(w, h);
      final scale = short >= targetShort ? 1.0 : targetShort / short;
      final resized = scale == 1.0
          ? crop
          : img.copyResize(
              crop,
              width: (w * scale).round(),
              height: (h * scale).round(),
            );

      final outPath = _withSuffix(imageFile.path, suffix, fallbackExt: '.jpg');
      File(outPath).writeAsBytesSync(img.encodeJpg(resized, quality: 95));
      return File(outPath);
    }

    final thirdW = (W / 3).round();
    final pad = (W * 0.04).round(); // a little horizontal padding

    final left = saveCrop(0, 0, thirdW + pad, H, '_roiL');
    final right = saveCrop(W - (thirdW + pad), 0, thirdW + pad, H, '_roiR');
    final center = saveCrop(
      (W - thirdW) ~/ 2 - pad ~/ 2,
      0,
      thirdW + pad,
      H,
      '_roiC',
    );

    return [left, right, center];
  }

  // Crop around the face with padding and save a 300x300 image.
  static Future<String?> _cropFace(File imageFile, Face face) async {
    final bytes = await imageFile.readAsBytes();
    final original = img.decodeImage(bytes);
    if (original == null) return null;

    final rect = face.boundingBox;
    const paddingFactor = 0.4; // 40% around face

    int newX = (rect.left - rect.width * paddingFactor).toInt().clamp(
      0,
      original.width,
    );
    int newY = (rect.top - rect.height * paddingFactor).toInt().clamp(
      0,
      original.height,
    );
    int newW = (rect.width * (1 + 2 * paddingFactor)).toInt();
    int newH = (rect.height * (1 + 2 * paddingFactor)).toInt();

    // Clamp width/height to image bounds
    newW = newW.clamp(0, original.width - newX);
    newH = newH.clamp(0, original.height - newY);

    final cropped = img.copyCrop(
      original,
      x: newX,
      y: newY,
      width: newW,
      height: newH,
    );
    final resized = img.copyResize(cropped, width: 300, height: 300);

    final path = _withSuffix(imageFile.path, '_cropped', fallbackExt: '.jpg');
    final outBytes = img.encodeJpg(resized, quality: 92);
    await File(path).writeAsBytes(outBytes);
    return path;
  }

  static String _withSuffix(
    String path,
    String suffix, {
    String fallbackExt = '.jpg',
  }) {
    final i = path.lastIndexOf('.');
    if (i <= 0) return path + suffix + fallbackExt;
    final base = path.substring(0, i);
    final ext = path.substring(i);
    return base + suffix + ext;
  }

  /// Run OCR on an image file (OPTIONAL: detect & crop face).
  static Future<OcrResult> extractData(
    File imageFile, {
    bool detectAndCropFace = false,
  }) async {
    // --- Face detection (optional) ---
    bool? faceOk;
    String? faceError;
    String? facePath;

    if (detectAndCropFace) {
      final r = await _detectFace(imageFile);
      if (r.error != null) {
        faceOk = false;
        faceError = r.error;
      } else {
        faceOk = true;
        facePath = await _cropFace(imageFile, r.face!);
      }
    }
    final inputImage = InputImage.fromFile(imageFile);
    final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
    final recognizedText = await textRecognizer.processImage(inputImage);
    print("=========== ðŸ†• OCR Extracted Text ===========");

    for (TextBlock block in recognizedText.blocks) {
      print("Block: ${block.text}");

      for (TextLine line in block.lines) {
        print("  Line: ${line.text}");

        for (TextElement element in line.elements) {
          print("    Element: ${element.text}");
        }
      }
    }

    print("============================================");
    await textRecognizer.close();

    final rawText = recognizedText.text;

    // Regex patterns for card data
    final nif = OcrParser.extractNIF(rawText);
    final nin = OcrParser.extractNIN(rawText);
    final cardNumber = OcrParser.extractCardNumber(rawText);
    final familyName = OcrParser.extractFamilyName(rawText);
    final familyNamePassport = OcrParser.extractFamilyNamePassport(rawText);
    final cardNumberPassport = OcrParser.extractCardNumberPassport(rawText);
    final societyName = OcrParser.extractRaisonSociale(rawText);
    final givenName = OcrParser.extractGivenName(rawText);
    final birthdate = OcrParser.extractBirthdate(rawText);
    final expiryDate = OcrParser.extractEndDate(rawText);
    final rhfactor = OcrParser.extractRhFactor(rawText);

    for (final block in recognizedText.blocks) {
      for (final line in block.lines) {
        // Normalize OCR output
        String text = line.text
            .replaceAll(RegExp(r'\s+'), '') // remove spaces/newlines
            .replaceAll('O', '0') // OCR O â†’ 0
            .replaceAll('I', '1') // OCR I â†’ 1
            .replaceAll('l', '1'); // OCR lowercase L â†’ 1

        // --- NIN: 18 consecutive digits ---

        // --- Card Number: 9 alphanumeric, must have letters + digits ---
      }
    }

    return OcrResult(
      nin: nin,
      nif: nif,
      cardNumber: cardNumber,
      cardNumberPassport: cardNumberPassport,
      familyName: familyName,
      societyName: societyName,
      familyNamePassport: familyNamePassport,
      givenName: givenName,
      birthdate: birthdate,
      expiryDate: expiryDate,
      rhfactor: rhfactor,
      faceOk: faceOk,
      faceError: faceError,
      facePath: facePath,
    );
  }
}

/// Helpers to parse MRZ-style or OCR text
class OcrParser {
  static String? _findMrzNameLine(String text) {
    final lines = text.toUpperCase().split(RegExp(r'[\r\n]+'));

    // Keep lines that look like MRZ names: have "<<", mostly Aâ€“Z or "<", no digits
    final candidates = lines.where((l) {
      final cleaned = l.replaceAll(' ', '');
      if (!cleaned.contains('<<')) return false;

      final hasDigits = RegExp(r'\d').hasMatch(cleaned);
      if (hasDigits) return false; // name line should not contain digits

      final validOnly = cleaned.replaceAll(RegExp(r'[^A-Z<]'), '');
      final ratio = validOnly.isEmpty ? 0.0 : validOnly.length / cleaned.length;

      return cleaned.length >= 10 && ratio > 0.8;
    }).toList();

    if (candidates.isEmpty) return null;

    // Pick the longest candidate (usually the name line)
    candidates.sort((a, b) => b.length.compareTo(a.length));
    return candidates.first;
  }

  // --- UPDATED: extracts only letters from the family name (surname) ---
  static String extractFamilyName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final parts = line.split('<<');
    if (parts.isEmpty) return '';

    // Keep only Aâ€“Z, drop everything else
    return parts[0].replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String extractFamilyNamePassport(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final lowerLine = line.toLowerCase();
    final startIndex = lowerLine.indexOf('p<dza');
    if (startIndex != -1) {
      final fromIndex = startIndex + 5; // skip "p<dza"
      final endIndex = lowerLine.indexOf('<<', fromIndex);
      if (endIndex != -1 && endIndex > fromIndex) {
        final rawName = line.substring(fromIndex, endIndex);
        // Remove any non-letter characters
        final cleaned = rawName.replaceAll(RegExp(r'[^A-Za-z]'), '');
        if (cleaned.isNotEmpty) {
          return cleaned.toUpperCase();
        }
      }
    }

    return '';
  }

  // --- UPDATED: extracts only letters from the given name(s) ---
  static String extractGivenName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final upper = line.toUpperCase();
    final start = upper.indexOf('<<');
    if (start == -1) return '';

    final from = start + 2;
    if (from >= upper.length) return '';

    final end = upper.indexOf('<', from);
    if (end == -1 || end <= from) return '';

    final given = upper.substring(from, end);
    // Keep only Aâ€“Z (drop any stray chars/spaces)
    return given.replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String? extractBirthdate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'([\d\s]{6,10})\s*[mf]').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _afterLabelOnLine(String text, String label) {
    final upper = text.toUpperCase();
    final labelUpper = label.toUpperCase();
    final i = upper.indexOf(labelUpper);
    if (i == -1) return '';

    // Slice after the label using the ORIGINAL text (to keep real chars)
    final start = i + labelUpper.length;
    var after = text.substring(start);

    // Trim leading separators like colon, dash, spaces
    after = after.replaceFirst(RegExp(r'^\s*[:ï¼š\-]?\s*'), '');

    // Keep only until the end of the current line
    final lineEnd = after.indexOf(RegExp(r'[\r\n]'));
    final line = (lineEnd == -1) ? after : after.substring(0, lineEnd);

    return line.trim();
  }

  static String extractNIN(String text) {
    final normalized = text.replaceAll(RegExp(r'[ \t\-]'), '');
    final match = RegExp(r'\d{18}').firstMatch(normalized);
    return match?.group(0) ?? '';
  }

  /// Extract NIF (digits right after the "NIF" label)
  static String extractNIF(String text) {
    final normalized = text.toUpperCase();
    final start = normalized.indexOf("NIF");
    if (start == -1) return "";

    final after = normalized.substring(start + 3); // skip "NIF"
    final match = RegExp(r'(\d{10,20})').firstMatch(after);
    return match?.group(1) ?? "";
  }

  /// Extract Raison Sociale (after "RAISON SOCIALE")
  static String extractRaisonSociale(String text) {
    // Work line-by-line to avoid over-matching across lines
    final lines = text.split(RegExp(r'\r?\n'));
    final upper = lines.map((l) => l.toUpperCase().trim()).toList();

    // 2) Fallback: line starting with a legal form
    final legalStart = RegExp(
      r'^(SARL|SPA|EURL|SNC|SCS|SCA|SAS|ETS|ETB)\b(.+)?$',
    );
    for (final line in upper) {
      final m = legalStart.firstMatch(line);
      if (m != null) {
        return _cleanupCompany(line);
      }
    }

    return "";
  }

  /// Cleans common noise, trims trailing labels, and keeps useful chars.
  /// Includes accented capitals common in FR (Ã‡, Ã‰, Ãˆ, Ã‚, ÃŠ, ÃŽ, Ã”, Ã›, Ã„, Ã‹, Ã, Ã–, Ãœ, Å¸),
  /// and ligatures (Ã†, Å’).
  static String _cleanupCompany(String s) {
    // Stop at next label if present (RC, NIF, NIS, IF, etc.)
    s = s.split(RegExp(r'\b(NIF|NÂ°\s*RC|RC|NIS|IF|ID\s*FISCAL|AI)\b')).first;

    // Normalize spaces
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    // Keep letters (incl. accents), digits, and common punctuation in names
    s = s.replaceAll(RegExp(r"[^A-Z0-9Ã€Ã‚Ã„Ã‡Ã‰ÃˆÃŠÃ‹ÃŽÃÃ”Ã–Ã™Ã›ÃœÅ¸Ã†Å’&\-\.' ]"), '');

    // Collapse inner multiple spaces again if cleaning introduced doubles
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    return s;
  }

  static String extractCardNumberPassport(String text) {
    // Remove spaces before processing
    final normalized = text.replaceAll(' ', '');

    final regex = RegExp(r'(\d{9})(?=\dDZA)');
    final match = regex.firstMatch(normalized);
    if (match != null) {
      return match.group(1) ?? '';
    }
    return '';
  }

  static String extractCardNumber(String text) {
    if (text.isEmpty) return '';

    // Normalize: drop all non-alphanumerics so spacing/colons/dashes don't matter
    final normalized = text.replaceAll(RegExp(r'[^A-Za-z0-9]'), '');

    // 1) Prefer a match immediately after "IDDZA"
    final afterPrefix = RegExp(
      r'DZA([A-Za-z]\d{8}|\d{9})',
    ).firstMatch(normalized);
    if (afterPrefix != null) {
      return (afterPrefix.group(1) ?? '').toUpperCase();
    }

    // 2) Otherwise, find the first occurrence anywhere
    final anyMatch = RegExp(r'([A-Za-z]\d{8}|\d{9})').firstMatch(normalized);
    if (anyMatch != null) {
      return (anyMatch.group(1) ?? '').toUpperCase();
    }

    return '';
  }

  static String? extractRhFactor(String text) {
    final validGroups = ["O+", "O-", "A+", "A-", "AB+", "AB-"];

    for (final group in validGroups) {
      if (text.contains(group)) {
        return group;
      }
    }
    return null; // nothing found
  }

  static String? extractEndDate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'[mf]\s*([\d\s]{6,10})').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _formatDate(String yyMMdd) {
    int year = int.parse(yyMMdd.substring(0, 2));
    String month = yyMMdd.substring(2, 4);
    String day = yyMMdd.substring(4, 6);

    // Handle 20th & 21st century correction
    int fullYear = (year > 50) ? (1900 + year) : (2000 + year);

    return '$day.$month.$fullYear';
  }
}
