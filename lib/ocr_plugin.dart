library;

import 'dart:io';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';
import 'ocr_plugin_platform_interface.dart';
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'package:image/image.dart' as img;

/// Data holder for OCR extraction
class OcrResult {
  final String? nin;
  final String? nif;
  final String? cardNumber;
  final String? cardNumberPassport;
  final String? familyName;
  final String? societyName;
  final String? familyNamePassport;
  final String? givenName;
  final String? birthdate;
  final String? expiryDate;
  final String? rhfactor;
  final String? bp;
  final String? articleNumber;
  final String? rcn;
  final String? rcnarab;
  final String? authority;

  OcrResult({
    this.nin,
    this.nif,
    this.cardNumber,
    this.cardNumberPassport,
    this.familyName,
    this.societyName,
    this.familyNamePassport,
    this.givenName,
    this.birthdate,
    this.expiryDate,
    this.rhfactor,
    this.bp,
    this.articleNumber,
    this.rcn,
    this.rcnarab,
    this.authority,
  });

  Map<String, dynamic> toJson() => {
        'nin': nin,
        'nif': nif,
        'cardNumber': cardNumber,
        'cardNumberPassport': cardNumberPassport,
        'familyName': familyName,
        'societyName': societyName,
        'familyNamePassport': familyNamePassport,
        'givenName': givenName,
        'birthdate': birthdate,
        'expiryDate': expiryDate,
        'RhFactor': rhfactor,
        'bp': bp,
        'articleNumber': articleNumber,
        'rcn': rcn,
        'rcnarab': rcnarab,
        'authority': authority,
      };

  factory OcrResult.fromJson(Map<String, dynamic> json) => OcrResult(
        nin: json['nin'],
        nif: json['nif'],
        cardNumber: json['cardNumber'],
        cardNumberPassport: json['cardNumberPassport'],
        familyName: json['familyName'],
        societyName: json['societyName'],
        familyNamePassport: json['familyNamePassport'],
        givenName: json['givenName'],
        birthdate: json['birthdate'],
        expiryDate: json['expiryDate'],
        rhfactor: json['RhFactor'],
        bp: json['bp'],
        rcn: json['rcn'],
        rcnarab: json['rcnarab'],
        articleNumber: json['articleNumber'],
        authority: json['authority'],
      );
}

/// Main plugin API exposed to Flutter apps
class OcrPlugin {
  /// Test method generated by the plugin template
  static Future<String?> getPlatformVersion() {
    return OcrPluginPlatform.instance.getPlatformVersion();
  }

  /// Detect face inside ID card and return cropped image file
  static Future<File?> detectFaceAndCrop(File imageFile) async {
    final inputImage = InputImage.fromFile(imageFile);

    final options = FaceDetectorOptions(
      performanceMode: FaceDetectorMode.accurate,
      enableContours: false,
      enableLandmarks: false,
    );

    final faceDetector = FaceDetector(options: options);
    final faces = await faceDetector.processImage(inputImage);

    if (faces.isEmpty) {
      print("No face detected in ID card");
      return null;
    }

    // Take the biggest face (in case multiple are found)
    final face = faces.reduce((a, b) =>
        a.boundingBox.width * a.boundingBox.height >
                b.boundingBox.width * b.boundingBox.height
            ? a
            : b);

    // Load image with 'image' package for cropping
    final bytes = await imageFile.readAsBytes();
    final decoded = img.decodeImage(bytes);
    if (decoded == null) return null;

    final box = face.boundingBox;
    final left = box.left.toInt().clamp(0, decoded.width);
    final top = box.top.toInt().clamp(0, decoded.height);
    final right = box.right.toInt().clamp(0, decoded.width);
    final bottom = box.bottom.toInt().clamp(0, decoded.height);

    final cropped = img.copyCrop(decoded,
        x: left, y: top, width: right - left, height: bottom - top);

    // Save cropped face to file
    final croppedFile = File(
        "${imageFile.parent.path}/cropped_face_${DateTime.now().millisecondsSinceEpoch}.png");
    await croppedFile.writeAsBytes(img.encodePng(cropped));

    await faceDetector.close();
    return croppedFile;
  }

  /// Run OCR on an image file (OCR only â€“ no face detection)
  static Future<OcrResult> extractData(File imageFile) async {
    final inputImage = InputImage.fromFile(imageFile);
    final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
    final recognizedText = await textRecognizer.processImage(inputImage);

    print("=========== ðŸ†• OCR Extracted Text ===========");
    for (TextBlock block in recognizedText.blocks) {
      print("Block: ${block.text}");
      for (TextLine line in block.lines) {
        print("  Line: ${line.text}");
        for (TextElement element in line.elements) {
          print("    Element: ${element.text}");
        }
      }
    }
    print("============================================");

    await textRecognizer.close();
    final rawText = recognizedText.text;

    // Regex patterns for card data
    final nif = OcrParser.extractNIF(rawText);
    final nin = OcrParser.extractNIN(rawText);
    final cardNumber = OcrParser.extractCardNumber(rawText);
    final familyName = OcrParser.extractFamilyName(rawText);
    final familyNamePassport = OcrParser.extractFamilyNamePassport(rawText);
    final cardNumberPassport = OcrParser.extractCardNumberPassport(rawText);
    final societyName = OcrParser.extractRaisonSociale(rawText);
    final givenName = OcrParser.extractGivenName(rawText);
    final birthdate = OcrParser.extractBirthdate(rawText);
    final expiryDate = OcrParser.extractEndDate(rawText);
    final rhfactor = OcrParser.extractRhFactor(rawText);
    final bp = OcrParser.extractBP(rawText);
    final rcn = OcrParser.extractRCN(rawText);
    final rcnarab = OcrParser.extractRCNArabic(rawText);
    final articleNumber = OcrParser.extractArticleNumber(rawText);
    final authority = OcrParser.extractAuthority(rawText);

    return OcrResult(
      nin: nin,
      nif: nif,
      cardNumber: cardNumber,
      cardNumberPassport: cardNumberPassport,
      familyName: familyName,
      societyName: societyName,
      familyNamePassport: familyNamePassport,
      givenName: givenName,
      birthdate: birthdate,
      expiryDate: expiryDate,
      rhfactor: rhfactor,
      bp: bp,
      rcn: rcn,
      rcnarab: rcnarab,
      articleNumber: articleNumber,
      authority: authority,
    );
  }
}

/// Helpers to parse MRZ-style or OCR text
class OcrParser {
  static String? _findMrzNameLine(String text) {
    final lines = text.toUpperCase().split(RegExp(r'[\r\n]+'));

    // Keep lines that look like MRZ names: have "<<", mostly Aâ€“Z or "<", no digits
    final candidates = lines.where((l) {
      final cleaned = l.replaceAll(' ', '');
      if (!cleaned.contains('<<')) return false;

      final hasDigits = RegExp(r'\d').hasMatch(cleaned);
      if (hasDigits) return false; // name line should not contain digits

      final validOnly = cleaned.replaceAll(RegExp(r'[^A-Z<]'), '');
      final ratio = validOnly.isEmpty ? 0.0 : validOnly.length / cleaned.length;

      return cleaned.length >= 10 && ratio > 0.8;
    }).toList();

    if (candidates.isEmpty) return null;

    // Pick the longest candidate (usually the name line)
    candidates.sort((a, b) => b.length.compareTo(a.length));
    return candidates.first;
  }

  // --- UPDATED: extracts only letters from the family name (surname) ---
  static String extractFamilyName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final parts = line.split('<<');
    if (parts.isEmpty) return '';

    // Keep only Aâ€“Z, drop everything else
    return parts[0].replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String extractFamilyNamePassport(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final lowerLine = line.toLowerCase();
    final startIndex = lowerLine.indexOf('p<dza');
    if (startIndex != -1) {
      final fromIndex = startIndex + 5; // skip "p<dza"
      final endIndex = lowerLine.indexOf('<<', fromIndex);
      if (endIndex != -1 && endIndex > fromIndex) {
        final rawName = line.substring(fromIndex, endIndex);
        // Remove any non-letter characters
        final cleaned = rawName.replaceAll(RegExp(r'[^A-Za-z]'), '');
        if (cleaned.isNotEmpty) {
          return cleaned.toUpperCase();
        }
      }
    }

    return '';
  }

  // --- UPDATED: extracts only letters from the given name(s) ---
  static String extractGivenName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final upper = line.toUpperCase();
    final start = upper.indexOf('<<');
    if (start == -1) return '';

    final from = start + 2;
    if (from >= upper.length) return '';

    final end = upper.indexOf('<', from);
    if (end == -1 || end <= from) return '';

    final given = upper.substring(from, end);
    // Keep only Aâ€“Z (drop any stray chars/spaces)
    return given.replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String? extractBirthdate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'([\d\s]{6,10})\s*[mf]').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _afterLabelOnLine(String text, String label) {
    final upper = text.toUpperCase();
    final labelUpper = label.toUpperCase();
    final i = upper.indexOf(labelUpper);
    if (i == -1) return '';

    // Slice after the label using the ORIGINAL text (to keep real chars)
    final start = i + labelUpper.length;
    var after = text.substring(start);

    // Trim leading separators like colon, dash, spaces
    after = after.replaceFirst(RegExp(r'^\s*[:ï¼š\-]?\s*'), '');

    // Keep only until the end of the current line
    final lineEnd = after.indexOf(RegExp(r'[\r\n]'));
    final line = (lineEnd == -1) ? after : after.substring(0, lineEnd);

    return line.trim();
  }

  static String extractNIN(String text) {
    final normalized = text.replaceAll(RegExp(r'[ \t\-]'), '');
    final match = RegExp(r'\d{18}').firstMatch(normalized);
    return match?.group(0) ?? '';
  }

  /// Extract NIF (digits right after the "NIF" label)
  static String extractNIF(String text) {
    final normalized = text.toUpperCase();
    final start = normalized.indexOf("NIF");
    if (start == -1) return "";

    final after = normalized.substring(start + 3); // skip "NIF"
    final match = RegExp(r'(\d{10,20})').firstMatch(after);
    return match?.group(1) ?? "";
  }

  static String extractBP(String text) {
    if (text.isEmpty) return '';

    // Find "BP:" (case-insensitive), capture following digits (with optional spaces/dashes)
    final m = RegExp(
      r'BP\s*:\s*([0-9\s-]{10,})',
      caseSensitive: false,
    ).firstMatch(text);
    if (m == null) return '';

    // Keep digits only, then take the first 10
    final digits = (m.group(1) ?? '').replaceAll(RegExp(r'\D'), '');
    return digits.length >= 10 ? digits.substring(0, 10) : '';
  }

  // Extract exactly 11 digits that come after the label "Article" (case-insensitive).
  // Tolerates spaces/dashes/linebreaks between digits, then returns the first 11 digits found.
  static String extractArticleNumber(String text) {
    if (text.isEmpty) return '';

    // Normalize NBSP -> space
    final norm = text.replaceAll('\u00A0', ' ');

    // Match "ARTICLE" or "ARTICTE", optional colon, then collect digits (with spaces/dashes)
    final re = RegExp(
      r'ARTIC(?:LE|TE)\s*[:ï¼š]?\s*([0-9\s-]{11,})',
      caseSensitive: false,
    );
    final m = re.firstMatch(norm);
    if (m != null) {
      final digits = (m.group(1) ?? '').replaceAll(RegExp(r'\D'), '');
      return digits.length >= 11 ? digits.substring(0, 11) : '';
    }

    // Fallback: first 11 digits in a row anywhere (tolerate spaces/dashes)
    final any = RegExp(r'(?:\d[\s-]*){11}').firstMatch(norm);
    if (any != null) {
      final digits = any.group(0)!.replaceAll(RegExp(r'\D'), '');
      return digits.substring(0, 11);
    }

    return '';
  }

  // Returns the value after N./NÂ°/â„–/No (letters+digits with - / . allowed)
  // Extract value only when the line contains the full prefix:
  // "Registre de conmerce/agrÃ©ment N." (case-insensitive).
  // Also tolerates "commerce" vs "conmerce" and Ã©/e in "agrÃ©ment".
  static String extractRCN(String text) {
    if (text.isEmpty) return '';

    // Normalize odd spaces and collapse
    final norm = text
        .replaceAll('\u00A0', ' ') // NBSP
        .replaceAll('\u202F', ' ') // narrow NBSP
        .replaceAll(RegExp(r'\s+'), ' ')
        .trim();

    final re = RegExp(
      r'REGISTRE\s+DE\s+CO(?:MM|NM)ERCE\/AGR[Ã‰E]MENT\s*N\.\s*' // full prefix up to "N."
      r'([A-Za-z0-9][A-Za-z0-9\-\/\.â€“â€”-]*)', // token after N.
      caseSensitive: false,
      unicode: true,
    );

    final m = re.firstMatch(norm);
    return m?.group(1) ?? '';
  }

  /// Extract Raison Sociale (after "RAISON SOCIALE")
  static String extractRaisonSociale(String text) {
    // Work line-by-line to avoid over-matching across lines
    final lines = text.split(RegExp(r'\r?\n'));
    final upper = lines.map((l) => l.toUpperCase().trim()).toList();

    // 2) Fallback: line starting with a legal form
    final legalStart = RegExp(
      r'^(SARL|SPA|EURL|SNC|SCS|SCA|SAS|ETS|ETB)\b(.+)?$',
    );
    for (final line in upper) {
      final m = legalStart.firstMatch(line);
      if (m != null) {
        return _cleanupCompany(line);
      }
    }

    return "";
  }

  /// Cleans common noise, trims trailing labels, and keeps useful chars.
  /// Includes accented capitals common in FR (Ã‡, Ã‰, Ãˆ, Ã‚, ÃŠ, ÃŽ, Ã”, Ã›, Ã„, Ã‹, Ã, Ã–, Ãœ, Å¸),
  /// and ligatures (Ã†, Å’).
  static String _cleanupCompany(String s) {
    // Stop at next label if present (RC, NIF, NIS, IF, etc.)
    s = s.split(RegExp(r'\b(NIF|NÂ°\s*RC|RC|NIS|IF|ID\s*FISCAL|AI)\b')).first;

    // Normalize spaces
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    // Keep letters (incl. accents), digits, and common punctuation in names
    s = s.replaceAll(RegExp(r"[^A-Z0-9Ã€Ã‚Ã„Ã‡Ã‰ÃˆÃŠÃ‹ÃŽÃÃ”Ã–Ã™Ã›ÃœÅ¸Ã†Å’&\-\.' ]"), '');

    // Collapse inner multiple spaces again if cleaning introduced doubles
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    return s;
  }

  static String extractCardNumberPassport(String text) {
    // Remove spaces before processing
    final normalized = text.replaceAll(' ', '');

    final regex = RegExp(r'(\d{9})(?=\dDZA)');
    final match = regex.firstMatch(normalized);
    if (match != null) {
      return match.group(1) ?? '';
    }
    return '';
  }

  static String? extractRCNArabic(String text) {
    final pattern = RegExp(r'\d{2}/\s*\d{2}\s*-\s*\d{7,}\s*\d{2}');
    for (var line in text.split('\n')) {
      if (pattern.hasMatch(line)) {
        return line.trim(); // return the first match
      }
    }
    return null; // nothing found
  }

  static String extractCardNumber(String text) {
    if (text.isEmpty) return '';

    // Normalize: drop all non-alphanumerics so spacing/colons/dashes don't matter
    final normalized = text.replaceAll(RegExp(r'[^A-Za-z0-9]'), '');

    // 1) Prefer a match immediately after "IDDZA"
    final afterPrefix = RegExp(
      r'DZA([A-Za-z]\d{8}|\d{9})',
    ).firstMatch(normalized);
    if (afterPrefix != null) {
      return (afterPrefix.group(1) ?? '').toUpperCase();
    }

    // 2) Otherwise, find the first occurrence anywhere
    final anyMatch = RegExp(r'([A-Za-z]\d{8}|\d{9})').firstMatch(normalized);
    if (anyMatch != null) {
      return (anyMatch.group(1) ?? '').toUpperCase();
    }

    return '';
  }

static String? extractAuthority(String text) {
  // Normalize line breaks and uppercase for consistency
  final lines = text.split(RegExp(r'\r?\n')).map((l) => l.trim()).toList();

  for (int i = 0; i < lines.length; i++) {
    final line = lines[i].toUpperCase();
    // Match "AUTORITE" or "AUTORITÃ‰" (OCR may miss accents)
    if (line.contains("AUTORITE") || line.contains("AUTORITÃ‰")) {
      if (i + 1 < lines.length) {
        // Return the line just under AutoritÃ©
        return lines[i + 1].trim();
      }
    }
  }

  return null; // Not found
}

  static String? extractRhFactor(String text) {
    final validGroups = ["O+", "O-", "A+", "A-", "AB+", "AB-"];

    for (final group in validGroups) {
      if (text.contains(group)) {
        return group;
      }
    }
    return null; // nothing found
  }

  static String? extractEndDate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'[mf]\s*([\d\s]{6,10})').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _formatDate(String yyMMdd) {
    int year = int.parse(yyMMdd.substring(0, 2));
    String month = yyMMdd.substring(2, 4);
    String day = yyMMdd.substring(4, 6);

    // Handle 20th & 21st century correction
    int fullYear = (year > 50) ? (1900 + year) : (2000 + year);

    return '$day.$month.$fullYear';
  }
}
