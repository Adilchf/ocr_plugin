library ocr_plugin;

import 'dart:io';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';

import 'ocr_plugin_platform_interface.dart';

/// Data holder for OCR extraction
class OcrResult {
  final String? nin;
  final String? nif;
  final String? cardNumber;
  final String? cardNumberPassport;
  final String? familyName;
  final String? societyName;
  final String? familyNamePassport;
  final String? givenName;
  final String? birthdate;
  final String? expiryDate;
  final String? rhfactor;

  OcrResult({
    this.nin,
    this.nif,
    this.cardNumber,
    this.cardNumberPassport,
    this.familyName,
    this.societyName,
    this.familyNamePassport,
    this.givenName,
    this.birthdate,
    this.expiryDate,
    this.rhfactor,
  });

  Map<String, dynamic> toJson() => {
    'nin': nin,
    'nif': nif,
    'cardNumber': cardNumber,
    'cardNumberPassport': cardNumberPassport,
    'familyName': familyName,
    'societyName': societyName,
    'familyNamePassport': familyNamePassport,
    'givenName': givenName,
    'birthdate': birthdate,
    'expiryDate': expiryDate,
    'RhFactor': rhfactor,
  };

  factory OcrResult.fromJson(Map<String, dynamic> json) => OcrResult(
    nin: json['nin'],
    nif: json['nif'],
    cardNumber: json['cardNumber'],
    cardNumberPassport: json['cardNumberPassport'],
    familyName: json['familyName'],
    societyName: json['societyName'],
    familyNamePassport: json['familyNamePassport'],
    givenName: json['givenName'],
    birthdate: json['birthdate'],
    expiryDate: json['expiryDate'],
    rhfactor: json['RhFactor'],
  );
}

/// Main plugin API exposed to Flutter apps
class OcrPlugin {
  /// Test method generated by the plugin template
  static Future<String?> getPlatformVersion() {
    return OcrPluginPlatform.instance.getPlatformVersion();
  }

  /// Run OCR on an image file
  static Future<OcrResult> extractData(File imageFile) async {
    final inputImage = InputImage.fromFile(imageFile);
    final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
    final recognizedText = await textRecognizer.processImage(inputImage);
    print("=========== üÜï OCR Extracted Text ===========");

    for (TextBlock block in recognizedText.blocks) {
      print("Block: ${block.text}");

      for (TextLine line in block.lines) {
        print("  Line: ${line.text}");

        for (TextElement element in line.elements) {
          print("    Element: ${element.text}");
        }
      }
    }

    print("============================================");
    await textRecognizer.close();

    final rawText = recognizedText.text;

    // Regex patterns for card data
    final nif = OcrParser.extractNIF(rawText);
    final nin = OcrParser.extractNIN(rawText);
    final cardNumber = OcrParser.extractCardNumber(rawText);
    final familyName = OcrParser.extractFamilyName(rawText);
    final familyNamePassport = OcrParser.extractFamilyNamePassport(rawText);
    final cardNumberPassport = OcrParser.extractCardNumberPassport(rawText);
    final societyName = OcrParser.extractRaisonSociale(rawText);
    final givenName = OcrParser.extractGivenName(rawText);
    final birthdate = OcrParser.extractBirthdate(rawText);
    final expiryDate = OcrParser.extractEndDate(rawText);
    final rhfactor = OcrParser.extractRhFactor(rawText);

    for (final block in recognizedText.blocks) {
      for (final line in block.lines) {
        // Normalize OCR output
        String text = line.text
            .replaceAll(RegExp(r'\s+'), '') // remove spaces/newlines
            .replaceAll('O', '0') // OCR O ‚Üí 0
            .replaceAll('I', '1') // OCR I ‚Üí 1
            .replaceAll('l', '1'); // OCR lowercase L ‚Üí 1

        // --- NIN: 18 consecutive digits ---

        // --- Card Number: 9 alphanumeric, must have letters + digits ---
      }
    }

    return OcrResult(
      nin: nin,
      nif: nif,
      cardNumber: cardNumber,
      cardNumberPassport: cardNumberPassport,
      familyName: familyName,
      societyName: societyName,
      familyNamePassport: familyNamePassport,
      givenName: givenName,
      birthdate: birthdate,
      expiryDate: expiryDate,
      rhfactor: rhfactor,
    );
  }
}

/// Helpers to parse MRZ-style or OCR text
class OcrParser {
  static String? _findMrzNameLine(String text) {
    final lines = text.toUpperCase().split(RegExp(r'[\r\n]+'));

    // Keep lines that look like MRZ names: have "<<", mostly A‚ÄìZ or "<", no digits
    final candidates = lines.where((l) {
      final cleaned = l.replaceAll(' ', '');
      if (!cleaned.contains('<<')) return false;

      final hasDigits = RegExp(r'\d').hasMatch(cleaned);
      if (hasDigits) return false; // name line should not contain digits

      final validOnly = cleaned.replaceAll(RegExp(r'[^A-Z<]'), '');
      final ratio = validOnly.isEmpty ? 0.0 : validOnly.length / cleaned.length;

      return cleaned.length >= 10 && ratio > 0.8;
    }).toList();

    if (candidates.isEmpty) return null;

    // Pick the longest candidate (usually the name line)
    candidates.sort((a, b) => b.length.compareTo(a.length));
    return candidates.first;
  }

  // --- UPDATED: extracts only letters from the family name (surname) ---
  static String extractFamilyName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final parts = line.split('<<');
    if (parts.isEmpty) return '';

    // Keep only A‚ÄìZ, drop everything else
    return parts[0].replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String extractFamilyNamePassport(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final lowerLine = line.toLowerCase();
    final startIndex = lowerLine.indexOf('p<dza');
    if (startIndex != -1) {
      final fromIndex = startIndex + 5; // skip "p<dza"
      final endIndex = lowerLine.indexOf('<<', fromIndex);
      if (endIndex != -1 && endIndex > fromIndex) {
        final rawName = line.substring(fromIndex, endIndex);
        // Remove any non-letter characters
        final cleaned = rawName.replaceAll(RegExp(r'[^A-Za-z]'), '');
        if (cleaned.isNotEmpty) {
          return cleaned.toUpperCase();
        }
      }
    }

    return '';
  }

  // --- UPDATED: extracts only letters from the given name(s) ---
  static String extractGivenName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final upper = line.toUpperCase();
    final start = upper.indexOf('<<');
    if (start == -1) return '';

    final from = start + 2;
    if (from >= upper.length) return '';

    final end = upper.indexOf('<', from);
    if (end == -1 || end <= from) return '';

    final given = upper.substring(from, end);
    // Keep only A‚ÄìZ (drop any stray chars/spaces)
    return given.replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String? extractBirthdate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'([\d\s]{6,10})\s*[mf]').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _afterLabelOnLine(String text, String label) {
    final upper = text.toUpperCase();
    final labelUpper = label.toUpperCase();
    final i = upper.indexOf(labelUpper);
    if (i == -1) return '';

    // Slice after the label using the ORIGINAL text (to keep real chars)
    final start = i + labelUpper.length;
    var after = text.substring(start);

    // Trim leading separators like colon, dash, spaces
    after = after.replaceFirst(RegExp(r'^\s*[:Ôºö\-]?\s*'), '');

    // Keep only until the end of the current line
    final lineEnd = after.indexOf(RegExp(r'[\r\n]'));
    final line = (lineEnd == -1) ? after : after.substring(0, lineEnd);

    return line.trim();
  }

  static String extractNIN(String text) {
    final normalized = text.replaceAll(RegExp(r'[ \t\-]'), '');
    final match = RegExp(r'\d{18}').firstMatch(normalized);
    return match?.group(0) ?? '';
  }

  /// Extract NIF (digits right after the "NIF" label)
  static String extractNIF(String text) {
    final normalized = text.toUpperCase();
    final start = normalized.indexOf("NIF");
    if (start == -1) return "";

    final after = normalized.substring(start + 3); // skip "NIF"
    final match = RegExp(r'(\d{10,20})').firstMatch(after);
    return match?.group(1) ?? "";
  }

  /// Extract Raison Sociale (after "RAISON SOCIALE")
  static String extractRaisonSociale(String text) {
    // Work line-by-line to avoid over-matching across lines
    final lines = text.split(RegExp(r'\r?\n'));
    final upper = lines.map((l) => l.toUpperCase().trim()).toList();

    // 2) Fallback: line starting with a legal form
    final legalStart = RegExp(
      r'^(SARL|SPA|EURL|SNC|SCS|SCA|SAS|ETS|ETB)\b(.+)?$',
    );
    for (final line in upper) {
      final m = legalStart.firstMatch(line);
      if (m != null) {
        return _cleanupCompany(line);
      }
    }

    return "";
  }

  /// Cleans common noise, trims trailing labels, and keeps useful chars.
  /// Includes accented capitals common in FR (√á, √â, √à, √Ç, √ä, √é, √î, √õ, √Ñ, √ã, √è, √ñ, √ú, ≈∏),
  /// and ligatures (√Ü, ≈í).
  static String _cleanupCompany(String s) {
    // Stop at next label if present (RC, NIF, NIS, IF, etc.)
    s = s.split(RegExp(r'\b(NIF|N¬∞\s*RC|RC|NIS|IF|ID\s*FISCAL|AI)\b')).first;

    // Normalize spaces
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    // Keep letters (incl. accents), digits, and common punctuation in names
    s = s.replaceAll(RegExp(r"[^A-Z0-9√Ä√Ç√Ñ√á√â√à√ä√ã√é√è√î√ñ√ô√õ√ú≈∏√Ü≈í&\-\.' ]"), '');

    // Collapse inner multiple spaces again if cleaning introduced doubles
    s = s.replaceAll(RegExp(r'\s{2,}'), ' ').trim();

    return s;
  }

  static String extractCardNumberPassport(String text) {
    // Remove spaces before processing
    final normalized = text.replaceAll(' ', '');

    final regex = RegExp(r'(\d{9})(?=\dDZA)');
    final match = regex.firstMatch(normalized);
    if (match != null) {
      return match.group(1) ?? '';
    }
    return '';
  }

  static String extractCardNumber(String text) {
    if (text.isEmpty) return '';

    // Normalize: drop all non-alphanumerics so spacing/colons/dashes don't matter
    final normalized = text.replaceAll(RegExp(r'[^A-Za-z0-9]'), '');

    // 1) Prefer a match immediately after "IDDZA"
    final afterPrefix = RegExp(
      r'DZA([A-Za-z]\d{8}|\d{9})',
    ).firstMatch(normalized);
    if (afterPrefix != null) {
      return (afterPrefix.group(1) ?? '').toUpperCase();
    }

    // 2) Otherwise, find the first occurrence anywhere
    final anyMatch = RegExp(r'([A-Za-z]\d{8}|\d{9})').firstMatch(normalized);
    if (anyMatch != null) {
      return (anyMatch.group(1) ?? '').toUpperCase();
    }

    return '';
  }

  static String? extractRhFactor(String text) {
    final validGroups = ["O+", "O-", "A+", "A-", "AB+", "AB-"];

    for (final group in validGroups) {
      if (text.contains(group)) {
        return group;
      }
    }
    return null; // nothing found
  }

  static String? extractEndDate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'[mf]\s*([\d\s]{6,10})').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _formatDate(String yyMMdd) {
    int year = int.parse(yyMMdd.substring(0, 2));
    String month = yyMMdd.substring(2, 4);
    String day = yyMMdd.substring(4, 6);

    // Handle 20th & 21st century correction
    int fullYear = (year > 50) ? (1900 + year) : (2000 + year);

    return '$day.$month.$fullYear';
  }
}
