library ocr_plugin;

import 'dart:io';
import 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';

import 'ocr_plugin_platform_interface.dart';

/// Data holder for OCR extraction
class OcrResult {
  final String? nin;
  final String? cardNumber;
  final String? familyName;
  final String? givenName;
  final String? birthdate;
  final String? expiryDate;
  final String? rhfactor;

  OcrResult({
    this.nin,
    this.cardNumber,
    this.familyName,
    this.givenName,
    this.birthdate,
    this.expiryDate,
    this.rhfactor,
  });

  Map<String, dynamic> toJson() => {
    'nin': nin,
    'cardNumber': cardNumber,
    'familyName': familyName,
    'givenName': givenName,
    'birthdate': birthdate,
    'expiryDate': expiryDate,
    'RhFactor': rhfactor,
  };

  factory OcrResult.fromJson(Map<String, dynamic> json) => OcrResult(
    nin: json['nin'],
    cardNumber: json['cardNumber'],
    familyName: json['familyName'],
    givenName: json['givenName'],
    birthdate: json['birthdate'],
    expiryDate: json['expiryDate'],
    rhfactor: json['RhFactor'],
  );
}

/// Main plugin API exposed to Flutter apps
class OcrPlugin {
  /// Test method generated by the plugin template
  static Future<String?> getPlatformVersion() {
    return OcrPluginPlatform.instance.getPlatformVersion();
  }

  /// Run OCR on an image file
  static Future<OcrResult> extractData(File imageFile) async {
    final inputImage = InputImage.fromFile(imageFile);
    final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);
    final recognizedText = await textRecognizer.processImage(inputImage);
    print("=========== ðŸ†• OCR Extracted Text ===========");

    for (TextBlock block in recognizedText.blocks) {
      print("Block: ${block.text}");

      for (TextLine line in block.lines) {
        print("  Line: ${line.text}");

        for (TextElement element in line.elements) {
          print("    Element: ${element.text}");
        }
      }
    }

    print("============================================");
    await textRecognizer.close();

    String? nin, cardNumber;
    final rawText = recognizedText.text;

    // Regex patterns for card data

    final familyName = OcrParser.extractFamilyName(rawText);
    final givenName = OcrParser.extractGivenName(rawText);
    final birthdate = OcrParser.extractBirthdate(rawText);
    final expiryDate = OcrParser.extractEndDate(rawText);
    final RhFactor = OcrParser.extractRhFactor(rawText);

    for (final block in recognizedText.blocks) {
      for (final line in block.lines) {
        // Normalize OCR output
        String text = line.text
            .replaceAll(RegExp(r'\s+'), '') // remove spaces/newlines
            .replaceAll('O', '0') // OCR O â†’ 0
            .replaceAll('I', '1') // OCR I â†’ 1
            .replaceAll('l', '1'); // OCR lowercase L â†’ 1

        // --- NIN: 18 consecutive digits ---
        final ninRegex = RegExp(r'\d{18}');
        if (nin == null && ninRegex.hasMatch(text)) {
          nin = ninRegex.firstMatch(text)!.group(0);
        }

        // --- Card Number: 9 alphanumeric, must have letters + digits ---
        final cardRegex = RegExp(r'(?:\d{9}|[A-Z0-9]{9,}(?=.*\d))');

        if (cardNumber == null && cardRegex.hasMatch(text)) {
          cardNumber = cardRegex.firstMatch(text)!.group(0);
        }
      }
    }

    return OcrResult(
      nin: nin,
      cardNumber: cardNumber,
      familyName: familyName,
      givenName: givenName,
      birthdate: birthdate,
      expiryDate: expiryDate,
      rhfactor: RhFactor,
    );
  }
}

/// Helpers to parse MRZ-style or OCR text
class OcrParser {
  static String? _findMrzNameLine(String text) {
    final lines = text.toUpperCase().split(RegExp(r'[\r\n]+'));

    // Keep lines that look like MRZ names: have "<<", mostly Aâ€“Z or "<", no digits
    final candidates = lines.where((l) {
      final cleaned = l.replaceAll(' ', '');
      if (!cleaned.contains('<<')) return false;

      final hasDigits = RegExp(r'\d').hasMatch(cleaned);
      if (hasDigits) return false; // name line should not contain digits

      final validOnly = cleaned.replaceAll(RegExp(r'[^A-Z<]'), '');
      final ratio = validOnly.isEmpty ? 0.0 : validOnly.length / cleaned.length;

      return cleaned.length >= 10 && ratio > 0.8;
    }).toList();

    if (candidates.isEmpty) return null;

    // Pick the longest candidate (usually the name line)
    candidates.sort((a, b) => b.length.compareTo(a.length));
    return candidates.first;
  }

  // --- UPDATED: extracts only letters from the family name (surname) ---
  static String extractFamilyName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final parts = line.split('<<');
    if (parts.isEmpty) return '';

    // Keep only Aâ€“Z, drop everything else
    return parts[0].replaceAll(RegExp(r'[^A-Z]'), '');
  }

  // --- UPDATED: extracts only letters from the given name(s) ---
  static String extractGivenName(String text) {
    final line = _findMrzNameLine(text);
    if (line == null) return '';

    final parts = line.split('<<');
    if (parts.length < 2) return '';

    // After the first '<<' is GIVENNAME possibly with extra '<' padding.
    // Remove all non-letters to return just letters (no spaces).
    return parts[1].replaceAll(RegExp(r'[^A-Z]'), '');
  }

  static String? extractBirthdate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'([\d\s]{6,10})\s*[mf]').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String? extractRhFactor(String text) {
    final validGroups = ["O+", "O-", "A+", "A-", "AB+", "AB-"];

    for (final group in validGroups) {
      if (text.contains(group)) {
        return group;
      }
    }
    return null; // nothing found
  }

  static String? extractEndDate(String text) {
    final normalized = text.replaceAll('\n', ' ').toLowerCase();
    final match = RegExp(r'[mf]\s*([\d\s]{6,10})').firstMatch(normalized);

    if (match != null) {
      final rawDigits = match.group(1)?.replaceAll(RegExp(r'\s+'), '');
      if (rawDigits != null && rawDigits.length >= 6) {
        return _formatDate(rawDigits.substring(0, 6));
      }
    }
    return null;
  }

  static String _formatDate(String digits) {
    // Assuming YYMMDD format
    final year = digits.substring(0, 2);
    final month = digits.substring(2, 4);
    final day = digits.substring(4, 6);
    return '$day/$month/$year';
  }
}
